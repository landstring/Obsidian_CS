Здесь собраны конспекты лекцтй Мещерина по С++.

## Выражения

### Базовые операторы

```C
//Бинарные операторы
a + b  //Оператор +
a - b  //Оператор -
a * b  //Оператор *
a / b  //Оператор / (div для целых чисел)
a % b  //Оператор % (mod для целых чисел)
a << b //Оператор << побитового сдвига влево 
a >> b //Оператор >> побитового сдвига вправо 
a & b  //Оператор & побитового И 
a | b  //Оператор | побитового ИЛИ
a ^ b  //Оператор ^ побитовое исключающее ИЛИ 
a && b //Оператор && логического И
a || b //Оператор || логического ИЛИ

//унарные операторы 
!b //Оператор ! логического НЕ
~b //Оператор ~ побитовое НЕ 
-b //Оператор - унарный минус 
```

### Операторы присваивания 

```C
a = b //обычное присваивание, причем a должно быть lvalue, a b - rvalue
	  //Оператор присваивания по стандарту возвращает левую часть, а не правую
	  //и выполняются справа налево
a += b //a = a + b
a -= b //a = a - b
a *= b //a = a * b
a /= b //a = a / b
a %= b //a = a % b
a <<= b //a = a << b
a >>= b //a = a >> b
a &= b //a = a & b
a |= b //a = a | b
a ^= b //a = a ^ b
```

### Операторы сравнения 

```C
a == b;
a != b;
a < b;
a > b;
a <= b;
a >= b;
```

### Тернарный оператор

```C
x ? y : z //считает x и переводиться в boolean, если True, вернёт y, иначе вернёт z
```

### Инкремент и декремент

```C
a++ //a = a + 1, вернёт начальное значение, является rvalue 
a-- //a = a - 1, вернёт начальное значение, является rvalue 
++a //a = a + 1, вернёт конечное значение, является lvalue 
--a //a = a - 1, вернёт конечное значение, является lvalue 
```

### Оператор sizeof()

```C
sizeof(a) //вернёт кол-во байт в памяти, которое занимает объект типа a
```

### Оператор ,

```C
a = b, c = d //вычисляет слева направо и вернёт самую правую
```

## Управляющие конструкции

```C
if (bool-expression){
	statement;
}

while (bool-expression){
	statement;
}

do {
	statement;
} while (bool-expression)

for (declaration|expression; bool-expression; expression){
	statement;
}

switch (expression){
	case expression: statement;
	default: statement; //выполнится во всех других случаях 
}

break; //выйти из текущей конструкции
continue; //перейти к следующей иттерации 
return expression; // возврат из функции
goto [метка]; //переход к метке 
```

## Ошибки 

### Ошибки компиляции

Ошибка компиляции возникает на этапе компиляции cpp файла в исполняемый файл операционной системы. Возникает она тогда, когда компилятор не может перевести очередную команду в исполняемый код. 

Виды ошибок компиляции:

- Лексические ошибки 
```C
ab3 //компилятор не может прочитать выражение 
```

- Синтаксическая ошибка

Когда написана конструкция, компилятор может её прочесть, но не может её распарсить (понять). Допустим, не хватает закрывающей скобки или ;

- Семантическая ошибка

Когда компилятор смог понять выражение, смог его прочитать, но смысла у прочитанного нет или он неправильный. Например, вызвана переменная, которую не объявили до этого. Или, например, Вы выполняете операцию над объектом, который данный тип операции не поддерживает.

### Ошибки исполнения 

Когда компиляция была успешной, исполняемый файл создался, но в ходе работы что-то сломалось. Например, обращение к области памяти, которая не пренадлежит программе (ошибка segmentation fault), или глубина рекурсии превзошла максимально разрешённую (stack overflow). 

Эти ошибки нельзя поймать на этапе компиляции, о чём говорит теорема Райса[^1].

### Undefind behavior (UB)

Когда вы написали что-то в программе, что не описано в стандарте. Классический пример:

```C
int x = 2 << 40; //переполнение типа, что неопределено в стандарте
```

Если явно не сказано, или явно сказано, что неопределено, что делать в этой ситуации, компилятор может сделать всё, что угодно. 


## Модификаторы типов 

### Указатели

Тип данных, который служит для представления адресов в памяти. 

```C
int* x; //адрес в памяти для x
cout << *x; //здесь же произойдёт разыменование указателя и вернётся значение int 
int y;
cout << &y; //выведется адрес переменной y

//в массиве обращение по индексу работает так:
int a[100]; //завели массив
cout << a[5]; //1
cout << *(a + 5); //2
//1 и 2 эквивалентны, поэтому обратиться можно к 5 элементу даже вот так:
cout << 5[a]; 
```

[^1]: Теорема Райса — утверждение теории алгоритмов, согласно которому для любого нетривиального свойства вычислимых функций определение того, вычисляет ли произвольный алгоритм функцию с таким свойством, является алгоритмически неразрешимой задачей.