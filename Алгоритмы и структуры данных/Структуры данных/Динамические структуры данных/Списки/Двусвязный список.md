
Наиболее общий случай связных списков[^1]. Каждый элемент списка состоит из трех полей: информационного и двух ссылочных на следующий и предыдущий элементы: 

![[Pasted image 20230305183445.png]]

|                   | **В среднем случае** | **В худшем случае** |
| ----------------- | -------------------- | ------------------- |
| **Расход памяти** | О(n)                 | O(n)                |
| **Поиск**         | О(N)             | O(N)                |
| **Вставка**       | О(1)             | O(1)                |
| **Удаление**      | O(1)             | O(1)                |
|    **Индексация**               |          -                |           -          |

Рассмотрим основные функции для работы со списками: добавление элемента в конец списка, просмотр элементов списка, удаление элемента из списка, вставка элемента в список, поиск элемента, удаление всего списка.

Список описывается как struct следующим образом:

```C
struct list{
	int inf;
	list* next;
	list* prev;
}
```


Рассмотрим функцию добавления элемента в конец списка. По сложившейся традиции эта функция называется push():

```C
void push (list *&h, list *&t, int x){ //вставка элемента в конец списка
	list *r = new list; //создаем новый элемент
	r−>inf = x;
	r−>next = NULL; //всегда последний
	if (!h && !t){ //если список пуст 
		r−>prev = NULL; //первый элемент 
		h = r; //это голова 
	} 
	else{ 
		t−>next = r; //r - следующий для хвоста 
		r−>prev = t; //хвост - предыдущий для r 
	}
	t = r; //r теперь хвост 
}
```


Рассмотрим подробно функцию вставки элемента в список после определенного элемента. В качестве параметров передаются указатели на голову (h) и хвост (t) списка, указатель на элемент, после которого будем вставлять (r) и значение нового элемента (x): 

```C
void insert_after(node* r, int y){ // вставка после элемента
        node* p = new node;
        p->value = y;
        if (r == tail) { //если добавляем в конец списк 
            p->next = NULL;
            p->prev = r;
            r->next = p;
            tail = p;  
        }
        else {
            r->next->prev = p;
            p->next = r->next;
            p->prev = r;
            r->next = p;
        }
    }
```

Рассмотрим теперь удаление элемента из списка:

```C
void del_element(node* r) {
        if (r == head && r == tail) { //если единственный элемент 
            head = tail = NULL;
        }
        else if (head == r) { //если голова 
            head = head->next;
            head->prev = NULL;
        }
        else if (r == tail) { //если хвост 
            tail = tail->prev;
            tail->next = NULL;
        }
        else {
            r->next->prev = r->prev; //обмен указателями
            r->prev->next = r->next;
        }
        delete r;
    }
```

[^1]: см. [[Связный список]]