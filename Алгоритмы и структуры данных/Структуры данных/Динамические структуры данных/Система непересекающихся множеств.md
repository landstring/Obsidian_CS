Эта динамическая структура данных[^1] предоставляет следующие возможности. Изначально имеется несколько элементов, каждый из которых находится в отдельном (своём собственном) множестве. За одну операцию можно **объединить два каких-либо множества**, а также можно **запросить, в каком множестве** сейчас находится указанный элемент. Также, в классическом варианте, вводится ещё одна операция — создание нового элемента, который помещается в отдельное множество. 

Таким образом, базовый интерфейс данной структуры данных состоит всего из трёх операций:
-  make_set(x) - **добавляет** новый элемент x, помещая его в новое множество, состоящее из одного него.
-  union_sets(x, y) - **объединяет** два указанных множества (множество, в котором находится элемент x, и множество, в котором находится элемент y). 
-  find_set(x) - **возвращает, в каком множестве** находится указанный элемент x. На самом деле при этом возвращается один из элементов множества (называемый **представителем** или **лидером** (в англоязычной литературе "leader")). Этот представитель выбирается в каждом множестве самой структурой данных (и может меняться с течением времени, а именно, после вызовов union_sets). 


***Построение эффективной структуры данных***

Определимся сначала, в каком виде мы будем хранить всю информацию. 

Множества элементов мы будем хранить в виде **деревьев**: одно дерево соответствует одному множеству. Корень дерева — это представитель (лидер) множества. 

При реализации это означает, что мы заводим массив parent, в котором для каждого элемента мы храним ссылку на его предка в дерева. Для корней деревьев будем считать, что их предок — они сами (т.е. ссылка зацикливается в этом месте). 

**Наивная реализация**

Мы уже можем написать первую реализацию системы непересекающихся множеств. Она будет довольно неэффективной, но затем мы улучшим её с помощью двух приёмов, получив в итоге почти константное время работы. 

Итак, вся информация о множествах элементов хранится у нас с помощью массива parent. 

Чтобы создать новый элемент (операция make_set(v)), мы просто создаём дерево с корнем в вершине v, отмечая, что её предок — это она сама. 

Чтобы объединить два множества (операция union_sets(x, y)), мы сначала найдём лидеров множества, в котором находится x, и множества, в котором находится y. Если лидеры совпали, то ничего не делаем — это значит, что множества и так уже были объединены. В противном случае можно просто указать, что предок вершины b равен a - тем самым мы присоединили одно дерево к другому. 

Наконец, реализация операции поиска лидера (find_set(x)) проста: мы поднимаемся по предкам от вершины x, пока не дойдём до корня. Эту операцию удобно будет сделать рекурсивной. 

```C
void make_set (int v) {
	parent[v] = v;
}
 
int find_set (int v) {
	if (v == parent[v])
		return v;
	return find_set (parent[v]);
}
 
void union_sets (int a, int b) {
	a = find_set (a);
	b = find_set (b);
	if (a != b)
		parent[b] = a;
}
```

Впрочем, такая реализация системы непересекающихся множеств весьма **неэффективна**. Легко построить пример, когда после нескольких объединений множеств получится ситуация, что множество — это дерево, выродившееся в длинную цепочку. В результате каждый вызов find_set() будет работать на таком тесте за время порядка глубины дерева, т.е. за O(n). 

Это весьма далеко от той асимптотики, которую мы собирались получить (константное время работы). Поэтому рассмотрим две оптимизации, которые позволят (даже применённые по отдельности) значительно ускорить работу. 

**Эвристика сжатия пути**

Эта эвристика предназначена для ускорения работы find_set(x). 

Она заключается в том, что когда после вызова find_set(x) мы найдём искомого лидера p, то запомним, что у вершины x т всех пройденных по пути вершин - именно этот лидер p. Проще всего это сделать, перенаправив их parent[] на эту вершину p. 

Таким образом, у массива предков parent[] смысл несколько меняется: теперь это **сжатый массив предков**, т.е. для каждой вершины там может храниться не непосредственный предок, а предок предка, предок предка предка, и т.д. 

С другой стороны, понятно, что нельзя сделать, чтобы эти указатели parent всегда указывали на лидера: иначе при выполнении операции union_sets() пришлось бы обновлять лидеров у O(n) элементов. 

Таким образом, к массиву parent[] следует подходить именно как к массиву предков, возможно, частично сжатому. 

Новая реализация операции find_set():

```C
int find_set (int v) {
	if (v == parent[v])
		return v;
	return parent[v] = find_set(parent[v]);
}
```

Такая простая реализация делает всё, что задумывалось: сначала путём рекурсивных вызовов находится лидера множества, а затем, в процессе раскрутки стека, этот лидер присваивается ссылкам parent для всех пройденных элементов.

Реализовать эту операцию можно и нерекурсивно, но тогда придётся осуществлять два прохода по дереву: первый найдёт искомого лидера, второй — проставит его всем вершинам пути. Впрочем, на практике нерекурсивная реализация не даёт существенного выигрыша.

**Эвристика объединения по рангу**

Рассмотрим здесь другую эвристику, которая сама по себе способна ускорить время работы алгоритма, а в сочетании с эвристикой сжатия путей и вовсе способна достигнуть практически константного времени работы на один запрос в среднем.

Эта эвристика заключается в небольшом изменении работы union_sets(): если в наивной реализации то, какое дерево будет присоединено к какому, определяется случайно, то теперь мы будем это делать на основе рангов. 

Есть два варианта ранговой эвристики: в одном варианте рангом дерева называется **количество вершин** в нём, в другом — **глубина дерева** (точнее, верхняя граница на глубину дерева, поскольку при совместном применении эвристики сжатия путей реальная глубина дерева может уменьшаться).

В обоих вариантах суть эвристики одна и та же: при выполнении union_sets() будем присоединять дерево с меньшим рангом к дереву с большим рангом. 

Приведём реализацию **ранговой эвристики на основе размеров деревьев**: 

```C
void make_set (int v) {
	parent[v] = v;
	size[v] = 1;
}
 
void union_sets (int a, int b) {
	a = find_set (a);
	b = find_set (b);
	if (a != b) {
		if (size[a] < size[b])
			swap (a, b);
		parent[b] = a;
		size[a] += size[b];
	}
}
```

Приведём реализацию **ранговой эвристики на основе глубины деревьев**:

```C
void make_set (int v) {
	parent[v] = v;
	rank[v] = 0;
}
 
void union_sets (int a, int b) {
	a = find_set (a);
	b = find_set (b);
	if (a != b) {
		if (rank[a] < rank[b])
			swap (a, b);
		parent[b] = a;
		if (rank[a] == rank[b])
			++rank[a];
	}
}
```

Оба варианта ранговой эвристики являются эквивалентными с точки зрения асимптотики, поэтому на практике можно применять любую из них.


**Объединение эвристик: сжатие пути плюс ранговая эвристика**

Как уже упоминалось выше, совместное применение этих эвристик даёт особенно наилучший результат, в итоге достигая практически константного времени работы.

Я не буду приводить здесь доказательства асимптотики, поскольку оно весьма объёмно (см., например, Кормен, Лейзерсон, Ривест, Штайн "Алгоритмы. Построение и анализ"). Впервые это доказательство было проведено Тарьяном (1975 г.). 

Окончательный результат таков: при совместном применении эвристик сжатия пути и объединения по рангу время работы на один запрос получается $O(\alpha(n))$ в среднем, где $\alpha(n)$ - **обратная функция Аккермана**, которая растёт очень медленно, настолько медленно, что для всех разумных ограничений n она не превосходит 4 (примерно для $n \le 10^{600}$).

Именно поэтому про асимптотику работы системы непересекающихся множеств уместно говорить "почти константное время работы". 

Приведём здесь **итоговую реализацию системы непересекающихся множеств**, реализующую обе указанные эвристики (используется ранговая эвристика относительно глубин деревьев): 

```C
void make_set (int v) {
	parent[v] = v;
	rank[v] = 0;
}
 
int find_set (int v) {
	if (v == parent[v])
		return v;
	return parent[v] = find_set (parent[v]);
}
 
void union_sets (int a, int b) {
	a = find_set (a);
	b = find_set (b);
	if (a != b) {
		if (rank[a] < rank[b])
			swap (a, b);
		parent[b] = a;
		if (rank[a] == rank[b])
			++rank[a];
	}
}
```

[^1]: [[Динамическая структура данных]]
