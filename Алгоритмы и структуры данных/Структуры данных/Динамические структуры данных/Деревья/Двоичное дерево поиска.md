Двоичное дерево (см. [[Дерево]]), для которого выполняются следующие дополнительные условия: оба поддерева — левое и правое — являются двоичными деревьями поиска; у всех узлов левого поддерева произвольного узла X значения ключей данных меньше, нежели значение ключа данных самого узла X;

![[Pasted image 20230301211354.png]]

Простейшая реализация дерева бинарного поиска состоит в следующем:

1. Первый элемент всегда является корнем;
2. Если вставляемый элемент меньше корня, ищем подходящее место на левой ветке;
3. Если вставляемый элемент больше корня — на правой.

Например, построим дерево бинарного поиска для следующей последовательности: 
5, 3, 7, 1, 9, 4, 2, 8, 6, 0

![[Pasted image 20230301211601.png]] 

Сложность операций с деревом в О-символике (см. Алгоритм)

|                   | **В среднем случае** | **В худшем случае** |
| ----------------- | -------------------- | ------------------- |
| **Расход памяти** | О(n)                 | O(n)                |
| **Поиск**         | О(log N)             | O(N)                |
| **Вставка**       | О(log N)             | O(N)                |
| **Удаление**                  |        O(log N)              |           O(N)          |

Худшие случаи возникают из-за отсутствия балансировки дерева[^1]. Например, если при добавлении элементов в дерево будет встречаться отсортированная последовательность, то в дереве она выстроется в так называемый "бамбук", где элементы будут достигать путём линейного прохода по новому поддереву, а не логарифмического рекурсивного прохода по нему. На картинке пример такой ситуации: 

![[Pasted image 20230305012033.png]]

Структура для дерева: 

```C
struct tree{
	int inf;
	tree* right;
	tree* left;
	tree* parent;	
}
```

Создание узла: 

```C
tree *node(int x){//начальный узел
	tree *n = new tree;
	n->inf = x;
	n->left = n->right = NULL;
	n->parent = NULL;
	return n;
}
```

Вставка нового значения: 

```C
void insert(tree*& tr, int x) { {       //вставка
    tree* n = node(x);
    if (!tr) {                          //если дерево пустое - корень
        tr = n;
    }
    else {
        tree* y = tr;
        while (y) {                     //ищем куда вставлять
            if (n->inf > y->inf) {      //правая ветка
                if (y->right) {
                    y = y->right;
                }
                else {
                    n->parent = y;      //узел становится правым ребенком
                    y->right = n;
                    break;
                }
            }
            else if (n->inf < y->inf) { //левая ветка
                if (y->left) {
                    y = y->left;
                }
                else {
                    n->parent = y;      //узел становится левым ребенком
                    y->left = n;
                    break;
                }
            }
        }
    }
}
```

Симметричный обход:

```C
void inorder(tree *tr){//симметричный обход
	if (tr){
		inorder ( tr−>left);
		cout << tr->inf << " ";
		inorder ( tr−>right);
	}
}
```

Нахождение элемента: 

```C 
tree* find(tree* tr, int x) {//поиск
    if (!tr || x == tr->inf) //нашли или дошли до конца ветки
        return tr;
    if (x < tr->inf)
        return find(tr->left, x); //ищем по левой ветке
    else
        return find(tr->right, x); //ищем по правой ветке
}
```

Нахождение минимума на поддереве: 

```C
tree* Min(tree* tr) { //
    if (!tr->left) return tr;//нет левого ребенка
    else return Min(tr->left);//идем по левой ветке до конца

}
```

Нахождение следующего элемента: 

```C
tree* Next(tree* tr, int x) {//поиск следующего
    tree* n = find(tr, x);
    if (n->right)//если есть правый ребенок
        return Min(n->right);//min по правой ветке
    tree* y = n->parent; //родитель
    while (y && n == y->right) {//пока не дошли до корня или узел - правый ребенок
        n = y;//идем вверх по дереву
        y = y->parent;
    }
    return y;//возвращаем родителя
```

Удаление элемента из дерева: 

```C
void Delete(tree*& tr, tree* v) {//удаление узла
    tree* p = v->parent;
    if (!p && !v->right && !v->left) tr = NULL; //дерево содержит один узел
    else if (!v->left && !v->right) {//если нет детей
        if (p->left == v) //указатель у родителя меняем на NULL
            p->left = NULL;
        if (p->right == v)
            p->right = NULL;
        delete v;
    }
    else if (!v->left || !v->right) {//если только один ребенок
        if (!p) { //если удаляем корень, у которого 1 ребенок
            if (!v->left) { //если есть правый ребенок
                tr = v->right; //он становится корнем
                v->parent = NULL;
            }
            else { //аналогично для левого
                tr = v->left;
                v->parent = NULL;
            }
        }
        else {
            if (!v->left) {//если есть правый ребенок
                if (p->left == v) //если удаляемый узел явл. левым ребенком
                    p->left = v->right; //ребенок удаляемого узла становится левым ребенком своего "деда"
                else
                    p->right = v->right; ////ребенок удаляемого узла становится правым ребенком своего "деда"
                v->right->parent = p; //родителем ребенка становится его "дед"
            }
            else {//аналогично для левого ребенка
                if (p->left == v)
                    p->left = v->left;
                else
                    p->right = v->left;
                v->left->parent = p;
            }
            delete v;
        }
    }
    else {//есть оба ребенка
        tree* succ = Next(tr, v->inf);//следующий за удаляемым узлом
        v->inf = succ->inf; //присваиваем значение
        if (succ->parent->left == succ) {//если succ левый ребенок
            succ->parent->left = succ->right; //его правый ребенок становится левым ребенком своего "деда"
            if (succ->right) //если этот ребенок существует
                succ->right->parent = succ->parent; //его родителем становится "дед"
        }
        else { //аналогично если succ - правsq ребенок
            succ->parent->right = succ->right;
            if (succ->right)
                succ->right->parent = succ->parent;
        }
        delete succ;
    }
}
```

