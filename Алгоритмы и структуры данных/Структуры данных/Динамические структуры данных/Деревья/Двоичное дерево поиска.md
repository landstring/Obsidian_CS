Двоичное дерево (см. [[Дерево]]), для которого выполняются следующие дополнительные условия: оба поддерева — левое и правое — являются двоичными деревьями поиска; у всех узлов левого поддерева произвольного узла X значения ключей данных меньше, нежели значение ключа данных самого узла X;

![[Pasted image 20230301211354.png]]

Простейшая реализация дерева бинарного поиска состоит в следующем:

1. Первый элемент всегда является корнем;
2. Если вставляемый элемент меньше корня, ищем подходящее место на левой ветке;
3. Если вставляемый элемент больше корня — на правой.

Например, построим дерево бинарного поиска для следующей последовательности: 
5, 3, 7, 1, 9, 4, 2, 8, 6, 0

![[Pasted image 20230301211601.png]] 

Структура для дерева: 

```C
struct tree{
	int inf;
	tree* right;
	tree* left;
	tree* parent;	
}
```

Создание узла: 

```C
tree *node(int x){//начальный узел
	tree *n = new tree;
	n->inf = x;
	n->left = n->right = NULL;
	n->parent = NULL;
	return n;
}
```

Вставка нового значения: 

```C
void insert(tree*& tr, int x) { {       //вставка
    tree* n = node(x);
    if (!tr) {                          //если дерево пустое - корень
        tr = n;
    }
    else {
        tree* y = tr;
        while (y) {                     //ищем куда вставлять
            if (n->inf > y->inf) {      //правая ветка
                if (y->right) {
                    y = y->right;
                }
                else {
                    n->parent = y;      //узел становится правым ребенком
                    y->right = n;
                    break;
                }
            }
            else if (n->inf < y->inf) { //левая ветка
                if (y->left) {
                    y = y->left;
                }
                else {
                    n->parent = y;      //узел становится левым ребенком
                    y->left = n;
                    break;
                }
            }
        }
    }
}
```

Симметричный обход:

```C
void inorder(tree *tr){//симметричный обход
	if (tr){
		inorder ( tr−>left);
		cout << tr->inf << " ";
		inorder ( tr−>right);
	}
}
```

