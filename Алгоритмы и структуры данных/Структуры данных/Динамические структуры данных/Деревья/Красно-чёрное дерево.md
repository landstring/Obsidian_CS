[[Двоичное дерево поиска]], в котором баланс[^1] осуществляется на основе "цвета" узла дерева, который принимает только два значения: "красный" (англ. _red_) и "чёрный" (англ. _black_).

![[Pasted image 20230314190448.png]]

Пример красно-чёрного дерева.

При этом все листья дерева являются фиктивными и не содержат данных, но относятся к дереву и являются чёрными.

Для экономии памяти фиктивные листья можно сделать одним общим фиктивным листом. 

***Свойства***

Красно-чёрным называется бинарное поисковое дерево, у которого каждому узлу сопоставлен дополнительный атрибут — цвет и для которого выполняются следующие свойства:

1.  Каждый узел промаркирован красным или чёрным цветом
2.  Корень и конечные узлы (листья) дерева — чёрные
3.  У красного узла родительский узел — чёрный
4.  Все простые пути из любого узла x до листьев содержат одинаковое количество чёрных узлов
5.  Чёрный узел может иметь чёрного родителя

**Определение 1**

>Будем называть **чёрной высотой** (англ. _black-height_) вершины Х число чёрных вершин на пути из Х в лист.

**Лемма 1**

>В красно-чёрном дереве с чёрной высотой hb кол-во внутренних вершин не менее $2^{hb - 1} - 1$

Доказательство: 

Докажем методом мат. индукции[^2].

База индукции :

Если высота узла X равна 1, то Х - это лист, hb(x) = 1 => $2^{1 - 1} - 1 = 0$

Переход:

Так как любая внутренняя вершина (вершина, у которой высота положительна) имеет двух потомков, то применим предположение индукции к ним — их высоты на единицу меньше высоты Х. Тогда черные высоты детей могут быть hb(x) или hb(x) - 1 (если потомок красный или чёрный соответственно).

Тогда по предположению индукции в каждом из поддеревьев не менее $2^{hb(x) - 2} - 1$ вершин. Тогда всего в поддереве исходная вершина + $2*(2^{hb(x) - 2} - 1)$ =  $2^{hb(x) - 1} - 1$ вершин. 

Переход доказан 

Теперь, если мы рассмотрим корень всего дерева в качестве X, то получится, что всего вершин в дереве не менее $2^{hb(x) - 1} - 1$.

Следовательно, утверждение верно и для всего дерева.

**Теорема**

>Красно-чёрное дерево с N ключами имеет высоту h = O(log N).

Доказательство:

Рассмотрим красно-чёрное дерево с высотой h. Так как у красной вершины чёрные дети (по свойству 3) количество красных вершин не больше $\frac{h}{2}$. Тогда чёрных вершин не меньше, чем $\frac{h}{2} - 1$.

По доказанной лемме, для количества внутренних вершин в дереве N выполняется неравенство: 
$$N \ge \frac{h}{2} - 1$$
$log(N + 1)\ge\frac{h}{2}$  =>  $h\le2*log(N + 1)$ 

***Операции***

**Вставка элемента**

Каждый элемент вставляется вместо листа, поэтому для выбора места вставки идём от корня до тех пор, пока указатель на следующего сына не станет nil (то есть этот сын - лист).  Вставляем вместо него новый элемент с нулевыми потомками и красным цветом. Теперь проверяем балансировку. Если отец нового элемента черный, то никакое из свойств дерева не нарушено. Если же он красный, то нарушается свойство 3, для исправления достаточно рассмотреть два случая:
1. "Дядя" этого узла тоже красный. Тогда, чтобы сохранить свойства 3 и 4, просто перекрашиваем "отца" и "дядю" в чёрный цвет, а "деда" — в красный. В таком случае черная высота в этом поддереве одинакова для всех листьев и у всех красных вершин "отцы" черные. Проверяем, не нарушена ли балансировка. Если в результате этих перекрашиваний мы дойдём до корня, то в нём в любом случае ставим чёрный цвет, чтобы дерево удовлетворяло свойству 2.

![[Pasted image 20230314212358.png]]
2. "Дядя" чёрный. Если выполнить только перекрашивание, то может нарушиться постоянство чёрной высоты дерева по всем ветвям. Поэтому выполняем поворот. Если добавляемый узел был правым потомком, то необходимо сначала выполнить левое вращение, которое сделает его левым потомком. Таким образом, свойство 3 и постоянство черной высоты сохраняются.

![[Pasted image 20230314212520.png]]

***Удаление вершины***

При удалении вершины могут возникнуть три случая в зависимости от количества её детей:
* Если у вершины нет детей, то изменяем указатель на неё у родителя на nil
* Если у неё только один ребёнок, то делаем у родителя ссылку на него вместо этой вершины.
* Если же имеются оба ребёнка, то находим вершину со следующим значением ключа. У такой вершины нет левого ребёнка (так как такая вершина находится в правом поддереве исходной вершины и она самая левая в нем, иначе бы мы взяли ее левого ребенка. Иными словами сначала мы переходим в правое поддерево, а после спускаемся вниз в левое до тех пор, пока у вершины есть левый ребенок). Удаляем уже эту вершину описанным во втором пункте способом, скопировав её ключ в изначальную вершину.

Проверим балансировку дерева. Так как при удалении красной вершины свойства дерева не нарушаются, то восстановление балансировки потребуется только при удалении чёрной. Рассмотрим ребёнка удалённой вершины.

- Если брат этого ребёнка красный, то делаем вращение вокруг ребра между отцом и братом, тогда брат становится родителем отца. Красим его в чёрный, а отца — в красный цвет, сохраняя таким образом черную высоту дерева. Хотя все пути по-прежнему содержат одинаковое количество чёрных узлов, сейчас Х имеет чёрного брата и красного отца. Таким образом, мы можем перейти к следующему шагу.

```C
#include <iostream>

using namespace std;

template <typename T>
struct node {
	T inf;
	node* left;
	node* right;
	node* parent;
	bool red;
};

template <typename T>
class RedBlackTree {
private:
	node<T>* root; //корень дерева 
	node<T>* null; //мнимый лист дерева
	int size;

	void leftRotate(node<T>* v) {
		node<T>* y = v->right;
		v->right = y->left;
		if (y->left == this->null) {
			y->left->parent = v;
		}
		y->parent = v->parent;
		if (v->parent == nullptr) {
			this->root = y;
		}
		else if (v == v->parent->left) {
			v->parent->left = y;
		}
		else {
			v->parent->right = y;
		}
		y->left = v;
		v->parent = y;
	}

	void rightRotate(node<T>* v) {
		node<T>* y = v->left;
		v->left = y->right;
		if (y->right == this->null) {
			y->right->parent = v;
		}
		y->parent = v->parent;
		if (v->parent == nullptr) {
			this->root = y;
		}
		else if (v == v->parent->right) {
			v->parent->right = y;
		}
		else {
			v->parent->left = y;
		}
		y->right = v;
		v->parent = y;
	}


	node<T>* findNode(node<T>* subTree, T element) {
		if (subTree == null || element == subTree->inf) {
			return subTree;
		}

		if (element < subTree->inf) {
			return findNode(subTree->left, element);
		}
		else {
			return findNode(subTree->right, element);
		}
	}

	void insertBalance(node<T>* v) {
		node<T>* y;
		while (v->parent->red) { //пока отец красный (нарушается свойство КЧД 3). 
			if (v->parent == v->parent->parent->right) { //если отец - правый сын деда
				y = v->parent->parent->left; //дядя вставленной вершины
				if (y->red) { //первый случай, когда дядя тоже красный, то баланс не нарушен, можно просто перекрасить вершины
					y.red = false;
					v->parent = false;
					v->parent->parent->red = true;
					v = v->parent->parent; //перешли в нашего деда
				}
				else { //Случай, когда нет дяди
					if (v == v->parent->left) { //если вставленный - левый сын
						v = v->parent;
						rightRotate(v); //выполним правый разворот 
					}
					v->parent->red = false; //перекрасим отца в чёрный
					v->parent->parent->red = true; //а деда в красный
					leftRotate(v->parent->parent); //выполним левый разворот от деда
				}
			}
			else {
				y = v->parent->parent->right; //дядя вставленной вершины
				if (y->red) { //первый случай, когда дядя тоже красный, то баланс не нарушен, можно просто перекрасить вершины
					y.red = false;
					v->parent = false;
					v->parent->parent->red = true;
					v = v->parent->parent; //перешли в нашего деда
				}
				else { //Случай, когда нет дяди
					if (v == v->parent->right) { //если вставленный - правый сын
						v = v->parent;
						leftRotate(v); //выполним правый разворот 
					}
					v->parent->red = false; //перекрасим отца в чёрный 
					v->parent->parent->red = true; //а деда в красный
					rightRotate(v->parent->parent); //выполним левый разворот от деда
				}
			}
			if (v == this->root) {
				break;
			}
		}
		this->root = false;
	}

public:
	RedBlackTree() { //конструктор
		null = new node;
		null->left = nullptr;
		null->right = nullptr;
		null->red = false;
		root = null;
		size = 0;
	}

	node<T>* find(T element) {
		return findNode(this->root, element);
	}

	void insert(T element) {
		node<T>* v = new node<T>;
		v->inf = element;
		v->parent = nullptr;
		v->left = null;
		v->right = null;
		v.red = true;

		node<T>* y = nullptr;
		node<T>* x = this->root;

		while (x != this->null) {
			y = x;
			if (v->inf < x->inf) {
				x = x->left;
			}
			else {
				x = x->right;
			}
		}

		v->parent = y;
		if (y == nullptr) {
			this->root = v;
		}
		else if (v->inf < y->inf) {
			y->left = v;
		}
		else {
			y->right = v;
		}

		if (v->parent == nullptr) { //если нет отца, то вершина - корень
			v->red = false;
			return;
		}

		if (v->parent->parent == nullptr) { //если нет деда, то нет и дяди
			return;
		}

		insertBalance(v);
	}

};

int main() {

}
```


[^1]: Дерево называется сбалансированным тогда и только тогда, когда для каждого его узла высоты его левого и правого поддеревьев отличаются не более чем на единицу.
[^2]: [[Метод математической индукции]] 