[[Двоичное дерево поиска]], в котором баланс[^1] осуществляется на основе "цвета" узла дерева, который принимает только два значения: "красный" (англ. _red_) и "чёрный" (англ. _black_).

![[Pasted image 20230314190448.png]]

Пример красно-чёрного дерева.

При этом все листья дерева являются фиктивными и не содержат данных, но относятся к дереву и являются чёрными.

Для экономии памяти фиктивные листья можно сделать одним общим фиктивным листом. 

***Свойства***

Красно-чёрным называется бинарное поисковое дерево, у которого каждому узлу сопоставлен дополнительный атрибут — цвет и для которого выполняются следующие свойства:

1.  Каждый узел промаркирован красным или чёрным цветом
2.  Корень и конечные узлы (листья) дерева — чёрные
3.  У красного узла родительский узел — чёрный
4.  Все простые пути из любого узла x до листьев содержат одинаковое количество чёрных узлов
5.  Чёрный узел может иметь чёрного родителя

**Определение 1**

>Будем называть **чёрной высотой** (англ. _black-height_) вершины Х число чёрных вершин на пути из Х в лист.

**Лемма 1**

>В красно-чёрном дереве с чёрной высотой hb кол-во внутренних вершин не менее $2^{hb - 1} - 1$

Доказательство: 

Докажем методом мат. индукции[^2].

База индукции :

Если высота узла X равна 1, то Х - это лист, hb(x) = 1 => $2^{1 - 1} - 1 = 0$

Переход:

Так как любая внутренняя вершина (вершина, у которой высота положительна) имеет двух потомков, то применим предположение индукции к ним — их высоты на единицу меньше высоты Х. Тогда черные высоты детей могут быть hb(x) или hb(x) - 1 (если потомок красный или чёрный соответственно).

Тогда по предположению индукции в каждом из поддеревьев не менее $2^{hb(x) - 2} - 1$ вершин. Тогда всего в поддереве исходная вершина + $2*(2^{hb(x) - 2} - 1)$ =  $2^{hb(x) - 1} - 1$ вершин. 

Переход доказан 

Теперь, если мы рассмотрим корень всего дерева в качестве X, то получится, что всего вершин в дереве не менее $2^{hb(x) - 1} - 1$.

Следовательно, утверждение верно и для всего дерева.

**Теорема**

>Красно-чёрное дерево с N ключами имеет высоту h = O(log N).

Доказательство:

Рассмотрим красно-чёрное дерево с высотой h. Так как у красной вершины чёрные дети (по свойству 3) количество красных вершин не больше $\frac{h}{2}$. Тогда чёрных вершин не меньше, чем $\frac{h}{2} - 1$.

По доказанной лемме, для количества внутренних вершин в дереве N выполняется неравенство: 
$$N \ge \frac{h}{2} - 1$$
$log(N + 1)\ge\frac{h}{2}$  =>  $h\le2*log(N + 1)$ 

***Операции***

**Вставка элемента**

Каждый элемент вставляется вместо листа, поэтому для выбора места вставки идём от корня до тех пор, пока указатель на следующего сына не станет nil (то есть этот сын - лист).  Вставляем вместо него новый элемент с нулевыми потомками и красным цветом. Теперь проверяем балансировку. Если отец нового элемента черный, то никакое из свойств дерева не нарушено. Если же он красный, то нарушается свойство 3, для исправления достаточно рассмотреть два случая:
1. "Дядя" этого узла тоже красный. Тогда, чтобы сохранить свойства 3 и 4, просто перекрашиваем "отца" и "дядю" в чёрный цвет, а "деда" — в красный. В таком случае черная высота в этом поддереве одинакова для всех листьев и у всех красных вершин "отцы" черные. Проверяем, не нарушена ли балансировка. Если в результате этих перекрашиваний мы дойдём до корня, то в нём в любом случае ставим чёрный цвет, чтобы дерево удовлетворяло свойству 2.

![[Pasted image 20230314212358.png]]
2. "Дядя" чёрный. Если выполнить только перекрашивание, то может нарушиться постоянство чёрной высоты дерева по всем ветвям. Поэтому выполняем поворот. Если добавляемый узел был правым потомком, то необходимо сначала выполнить левое вращение, которое сделает его левым потомком. Таким образом, свойство 3 и постоянство черной высоты сохраняются.

![[Pasted image 20230314212520.png]]

***Удаление вершины***

Рассмотрим случаи удаления вершины:

1) **Удаление красной вершины с 0 детьми**

В этом случае мы просто заменяем данную вершину на NULL-вершину. Никакие пункты из вышеописанных правил не нарушены (та же черная высота не нарушается), дерево все еще корректно.

![[Pasted image 20230316153002.png]]
2) **Удаление красной или черной вершины с 2 детьми**

Так как у вершины есть два ребенка (а то и поддерева), чтобы сделать наиболее безболезненное удаление, стоит найти кого поставить в качестве _замены_ на это же место. Эту замену мы можем найти в этих самых поддеревьях: из левого мы можем искать максимальное, а из правого -- минимальное:

![[Pasted image 20230316153833.png]]

Все же выбрав нужную вершину, нам надо сделать обмен **значений** с ней. Это очень важно, ведь если мы поменяем цвета, то у нас может нарушиться черная высота, а вот замена значений пройдет очень гладко (мы же специально выбрали максимальный или минимальный -- то есть порядок значений не нарушится).

Таким образом, нам останется удалить вершину, с которой мы произвели замену, а у нее уже точно **один** или **ноль** детей.

3) **Удаление черной вершины с 1 ребенком**

Теперь настало время рассмотреть только черные вершины. Данный случай с одним ребенком достаточно прост, но это только затишье перед бурей.

Итак, рассмотрим, как выглядит подобный вариант:
![[Pasted image 20230316154201.png]]

То есть опять же, мы можем поменять **значения** (не цвета!) и начать удалять вершину с **одним** или **нулем** детей. Черная высота (по крайней мере в пределах этой замены) остается той же.

4) **Удаление черной вершины с 0 детей**

Как можно уже заметить, при удалении черной вершины у нас неизбежно меняется черная высота, и у нас нет красных потомков, с которыми можно было бы сделать обмен и удалить уже их.

Так что мы удаляем вершину, заменяя ссылку на него на NULL, и производим **ребалансировку**.

**Warning:** начиная с этого момента рассматривается случай с **левой** удаляемой вершиной. Очевидно, если вершина была правым ребенком, все случаи просто отзеркаливаются (в реализации можно использовать схему "_вершина с той же ветки (левой/правой)_" и "_вершина с другой ветки_"):
![[Pasted image 20230316154435.png]]
_А еще впредь мы не особо будем утруждаться вырисовывать все NULL вершины отдельно (с некоторыми исключениями в виде рассмотрения частных случаев). Надо будет помнить, что черные вершины могут быть как NULL вершины, так и вершинами со значениями!_

> **Основная идея** -- выровнять черную высоту засчет наличия красной вершины где-то среди соседних, применяя перекрашивания и повороты. Если в пределах рассмотренной области нету красной вершины, мы перейдем к рекурсивному рассмотрению через родителя (но об этом позже).

1) Брат черный
	1. Хотя бы один ребенок брата красный
		Данный случай мы рассмотрим первым, так как имеются красные вершины в племянниках. Родительский цвет, кстати, нас не особо беспокоит (оба его ребенка черные, так что цвет родителя может быть как черный, так и красный, но на разницу черную высоту в данном поддереве оно все равно не влияет).
		Однако, мы так же разделим этот случай на два в зависимости от положения красного ребенка:
			a) Правый ребенок красный (левый -- любой)
			Мы перекрашиваем брата в **родительский** цвет, а его отца и красного ребенка -- в **черный** (цвет второго ребенка остается тем же). Далее требуется только сделать поворот влево:
			![[Pasted image 20230316161850.png]]
			Черная высота точно выравнена, дальнейшая ребалансировка не требуется.
			b) Левый ребенок красный (правый -- черный)
			Мы обмениваем цвета красного ребенка и брата, и делаем поворот вправо вокруг брата:
			![[Pasted image 20230316162118.png]]
			По изображению видно, что этого недостаточно, НО зато мы перешли к уже известному случаю -- брат стал черным, с правым красным ребенком. То есть переход к пункту 1.1.а 
	2. Оба ребенка брата - черные	 ![[Pasted image 20230316162954.png]]
	     перекрасим черного брата в **красный**, с целью выровнять высоту в пределах двух поддеревьев. Однако далее мы окрасим родительскую вершину в **черный** цвет, и:
	     - Если родительская вершина была красной, то мы заканчиваем алгоритм (черная высота выравнена засчет родительской вершины);
	     - Если родительская вершина была черной, то мы рекурсивно приступаем к процессу ребалансировки (черная высота же всего поддерева уменьшилась) с этого родителя, будто именно эта вершина и удалялась изначально.
2) Брат красный
	Но это еще не всё. У нас остались случаи с красным братом -- это было сделано потому, что этот случай сводится, опять же, к предыдущим. Но благо, что под конец это достаточно удобный и простой случай.

	Удобный он потому, так как красный цвет гарантирует, что родитель и дети будут обязательно черными, более того они обязательно должны быть вершинами со значениями (не NULL, можете проверить сами по черной высоте).

	Простой -- потому что достаточно перекрашивания вершин (родитель в **красный**, брат в **черный**) и одного поворота так, чтобы брат стал корнем данного поддерева:
	![[Pasted image 20230316163218.png]]
	Так мы переместили разность черных высот с корневой вершины данного поддерева на уровень ниже (мы ведь действительно просто переместили корень вниз...). То есть далее нам требуется разрешить конфликт черных высот в области _"удаленной"_ вершины и вершины _"c"._
	Для окончательной ребалансировки мы переходим к пункту 1) черный брат.


***Реализация на С++***

```C
template <typename T>
struct node {
	T inf;
	node* left;
	node* right;
	node* parent;
	bool red;
};

template <typename T>
class RedBlackTree {
private:
	node<T>* root; //корень дерева 
	node<T>* null; //мнимый лист дерева
	int size;

	void leftRotate(node<T>* v) {
		node<T>* y = v->right;
		v->right = y->left;
		if (y->left != this->null) {
			y->left->parent = v;
		}
		y->parent = v->parent;
		if (v->parent == nullptr) {
			this->root = y;
		}
		else if (v == v->parent->left) {
			v->parent->left = y;
		}
		else {
			v->parent->right = y;
		}
		y->left = v;
		v->parent = y;
	}

	void rightRotate(node<T>* v) {
		node<T>* y = v->left;
		v->left = y->right;
		if (y->right != this->null) {
			y->right->parent = v;
		}
		y->parent = v->parent;
		if (v->parent == nullptr) {
			this->root = y;
		}
		else if (v == v->parent->right) {
			v->parent->right = y;
		}
		else {
			v->parent->left = y;
		}
		y->right = v;
		v->parent = y;
	}

	node<T>* findNode(node<T>* subTree, T element) {
		if (subTree == this->null || element == subTree->inf) {
			return subTree;
		}

		if (element < subTree->inf) {
			return findNode(subTree->left, element);
		}
		else {
			return findNode(subTree->right, element);
		}
	}

	node<T>* minimum(node<T>* subTree) {
		while (subTree->left != this->null) {
			subTree = subTree->left;
		}
		return subTree;
	}

	void insertBalance(node<T>* v) {
		node<T>* y;
		while (v->parent->red) { //пока отец красный (нарушается свойство КЧД 3)-> 
			if (v->parent == v->parent->parent->right) { //если отец - правый сын деда
				y = v->parent->parent->left; //дядя вставленной вершины
				if (y->red) { //первый случай, когда дядя тоже красный, то баланс не нарушен, можно просто перекрасить вершины
					y->red = false;
					v->parent->red = false;
					v->parent->parent->red = true;
					v = v->parent->parent; //перешли в нашего деда
				}
				else { //Случай, когда нет дяди
					if (v == v->parent->left) { //если вставленный - левый сын
						v = v->parent;
						rightRotate(v); //выполним правый разворот 
					}
					v->parent->red = false; //перекрасим отца в чёрный
					v->parent->parent->red = true; //а деда в красный
					leftRotate(v->parent->parent); //выполним левый разворот от деда
				}
			}
			else {
				y = v->parent->parent->right; //дядя вставленной вершины
				if (y->red) { //первый случай, когда дядя тоже красный, то баланс не нарушен, можно просто перекрасить вершины
					y->red = false;
					v->parent->red = false;
					v->parent->parent->red = true;
					v = v->parent->parent; //перешли в нашего деда
				}
				else { //Случай, когда нет дяди
					if (v == v->parent->right) { //если вставленный - правый сын
						v = v->parent;
						leftRotate(v); //выполним правый разворот 
					}
					v->parent->red = false; //перекрасим отца в чёрный 
					v->parent->parent->red = true; //а деда в красный
					rightRotate(v->parent->parent); //выполним левый разворот от деда
				}
			}
			if (v == this->root) {
				break;
			}
		}
		this->root->red = false;
	}

	void deleteBalance(node<T>* v) {
		if (v->left != this->null && v->right != this->null) { //удаление красной вершины с двумя детьми
			node<T>* y = v->right;
			T tmp = y->inf;
			y->inf = v->inf;
			v->inf = tmp;
			deleteBalance(y);
			return;
		}
		else {
			if (v->red) { //чёрная высота при удалении не изменится
				if (v->parent->left == v) { 
					v->parent->left = this->null;
				}
				else {
					v->parent->right = this->null;
				}
				delete v;
				this->size--;
				return;
			}
			else { 
				if (v->left != this->null) {
					node<T>* y = v->left; 
					T tmp = y->inf;
					y->inf = v->inf;
					v->inf = tmp;
					deleteBalance(y);
					return;
				}
				else if (v->right != this->null) {
					node<T>* y = v->right;
					T tmp = y->inf;
					y->inf = v->inf;
					v->inf = tmp;
					deleteBalance(y);
					return;
				} 
				else { 
					if (v == this->root) {
						this->root = nullptr;
						size = 0;
					}
					else {
						node<T>* save = v;
						node<T>* s;
						while (v != this->root && !v->red) {
							if (v == v->parent->left) {
								s = v->parent->right;
								if (s->red) {
									s->red = false;
									v->parent->red = true;
									leftRotate(v->parent);
									s = v->parent->right;
								}
								if (!s->left->red && !s->right->red) {
									s->red = true;
									v = v->parent;
								}
								else {
									if (!s->right->red) {
										s->left->red = false;
										s->red = true;
										rightRotate(s);
										s = v->parent->right;
									}
									s->red = v->parent->red;
									v->parent->red = false;
									s->right->red = false;
									leftRotate(v->parent);
									v = this->root;
								}
							}
							else {
								s = v->parent->left;
								if (s->red) {
									s->red = false;
									v->parent->red = true;
									rightRotate(v->parent);
									s = v->parent->left;
								}

								if (!s->right->red && !s->right->red) {
									s->red = true;
									v = v->parent;
								}
								else {
									if (!s->left->red) {
										s->right->red = false;
										s->red = true;
										leftRotate(s);
										s = v->parent->left;
									}

									s->red = v->parent->red;
									v->parent->red = false;
									s->left->red = false;
									rightRotate(v->parent);
									v = this->root;
								}
							}
						}
						v->red = false;
						this->root->red = false;
						if (save->parent->left == save) {
							save->parent->left = this->null;
						}
						else {
							save->parent->right = this->null;
						}
						delete save;
						this->size--;
						return;
					}
				}
			}
		}
	}

	void inorder_start(node<T>* v) {
		if (v != this->null) {
			inorder_start(v->left);
			cout << v->inf << " ";
			inorder_start(v->right);
		}
	}

public:
	RedBlackTree() { //конструктор
		null = new node<T>;
		null->left = nullptr;
		null->right = nullptr;
		null->red = false;
		root = null;
		size = 0;
	}

	node<T>* find(T element) {
		return findNode(this->root, element);
	}

	void insert(T element) {
		node<T>* v = new node<T>;
		v->inf = element;
		v->parent = nullptr;
		v->left = this->null;
		v->right = this->null;
		v->red = true;

		this->size++;

		node<T>* y = nullptr;
		node<T>* x = this->root;

		while (x != this->null) {
			y = x;
			if (v->inf < x->inf) {
				x = x->left;
			}
			else {
				x = x->right;
			}
		}

		v->parent = y;
		if (y == nullptr) {
			this->root = v;
		}
		else if (v->inf < y->inf) {
			y->left = v;
		}
		else {
			y->right = v;
		}

		if (v->parent == nullptr) { //если нет отца, то вершина - корень
			v->red = false;
			return;
		}

		if (v->parent->parent == nullptr) { //если нет деда, то нет и дяди
			return;
		}
		insertBalance(v);
	}

	void erase(T element) {
		node<T>* v = this->findNode(this->root, element);
		if (v == this->null) {
			cout << "The node did not found!" << endl;
			return;
		}
		deleteBalance(v);
	}

	void inorder() {
		if (this->size > 0) {
			inorder_start(this->root);
		}
		else {
			cout << "The tree is empty!" << endl;
		}
	}

	int get_size() {
		return this->size;
	}
};](<#include %3Ciostream%3E

using namespace std;

template <typename T>
struct node {
	T inf;
	node* left;
	node* right;
	node* parent;
	bool red;
};

template <typename T>
class RedBlackTree {
private:
	node<T>* root; //корень дерева 
	node<T>* null; //мнимый лист дерева
	int size;

	void leftRotate(node<T>* v) {
		node<T>* y = v->right;
		v->right = y->left;
		if (y->left == this->null) {
			y->left->parent = v;
		}
		y->parent = v->parent;
		if (v->parent == nullptr) {
			this->root = y;
		}
		else if (v == v->parent->left) {
			v->parent->left = y;
		}
		else {
			v->parent->right = y;
		}
		y->left = v;
		v->parent = y;
	}

	void rightRotate(node<T>* v) {
		node<T>* y = v->left;
		v->left = y->right;
		if (y->right == this->null) {
			y->right->parent = v;
		}
		y->parent = v->parent;
		if (v->parent == nullptr) {
			this->root = y;
		}
		else if (v == v->parent->right) {
			v->parent->right = y;
		}
		else {
			v->parent->left = y;
		}
		y->right = v;
		v->parent = y;
	}

	node<T>* findNode(node<T>* subTree, T element) {
		if (subTree == this.null || element == subTree->inf) {
			return subTree;
		}

		if (element < subTree->inf) {
			return findNode(subTree->left, element);
		}
		else {
			return findNode(subTree->right, element);
		}
	}

	node<T>* minimum(node* subTree) {
		while (subTree->left != this->null) {
			subTree = subTree->left;
		}
		return subTree;
	}

	void insertBalance(node<T>* v) {
		node<T>* y;
		while (v->parent->red) { //пока отец красный (нарушается свойство КЧД 3). 
			if (v->parent == v->parent->parent->right) { //если отец - правый сын деда
				y = v->parent->parent->left; //дядя вставленной вершины
				if (y->red) { //первый случай, когда дядя тоже красный, то баланс не нарушен, можно просто перекрасить вершины
					y.red = false;
					v->parent = false;
					v->parent->parent->red = true;
					v = v->parent->parent; //перешли в нашего деда
				}
				else { //Случай, когда нет дяди
					if (v == v->parent->left) { //если вставленный - левый сын
						v = v->parent;
						rightRotate(v); //выполним правый разворот 
					}
					v->parent->red = false; //перекрасим отца в чёрный
					v->parent->parent->red = true; //а деда в красный
					leftRotate(v->parent->parent); //выполним левый разворот от деда
				}
			}
			else {
				y = v->parent->parent->right; //дядя вставленной вершины
				if (y->red) { //первый случай, когда дядя тоже красный, то баланс не нарушен, можно просто перекрасить вершины
					y.red = false;
					v->parent = false;
					v->parent->parent->red = true;
					v = v->parent->parent; //перешли в нашего деда
				}
				else { //Случай, когда нет дяди
					if (v == v->parent->right) { //если вставленный - правый сын
						v = v->parent;
						leftRotate(v); //выполним правый разворот 
					}
					v->parent->red = false; //перекрасим отца в чёрный 
					v->parent->parent->red = true; //а деда в красный
					rightRotate(v->parent->parent); //выполним левый разворот от деда
				}
			}
			if (v == this->root) {
				break;
			}
		}
		this->root = false;
	}

public:
	RedBlackTree() { //конструктор
		null = new node;
		null->left = nullptr;
		null->right = nullptr;
		null->red = false;
		root = null;
		size = 0;
	}

	node<T>* find(T element) {
		return findNode(this->root, element);
	}

	void insert(T element) {
		node<T>* v = new node<T>;
		v->inf = element;
		v->parent = nullptr;
		v->left = null;
		v->right = null;
		v.red = true;

		node<T>* y = nullptr;
		node<T>* x = this->root;

		while (x != this->null) {
			y = x;
			if (v->inf < x->inf) {
				x = x->left;
			}
			else {
				x = x->right;
			}
		}

		v->parent = y;
		if (y == nullptr) {
			this->root = v;
		}
		else if (v->inf < y->inf) {
			y->left = v;
		}
		else {
			y->right = v;
		}

		if (v->parent == nullptr) { //если нет отца, то вершина - корень
			v->red = false;
			return;
		}

		if (v->parent->parent == nullptr) { //если нет деда, то нет и дяди
			return;
		}
		insertBalance(v);
	}

	void erase(T element) {
		node<T>* v = this->findNode(this->root, element);

		if (v == this->null) {
			cout << "The node did not found!" << endl;
			return;
		}

		if (!v->left && !v->right) { //если у удаляемой вершины нет детей
			if (v == this.root) {
				this->root = this->null;
			}
			else {
				if (v->parent->right == v) {
					v->parent->right = this->null;
				}
				else {
					v->parent->left = this->null;
				}
			}
			return;
		}

		node<T>* x = this->null;
		node<T>* y = v;

		if (v->left == this->null) { //если у вершины только правый ребёнок 
			if (v == this.root) { //если удаляемая вершина - корень
				root = v->right;
			}
			else {
				if (v->parent->left == v) { 
					v->parent.left = v->right;
				}
				else {
					v->parent->right = v->right;
				}
			}
			v->right->parent = v->parent; //меняем родителя правого ребёнка на родителя удаляемой вершины
		}
		else if (v->right == this->null) {
			if (v == this.root) { //если удаляемая вершина - корень
				root = v->left;
			}
			else {
				if (v->parent->left == v) {
					v->parent.left = v->left;
				}
				else {
					v->parent->right = v->left;
				}
			}
			v->left->parent = v->parent;
		}
		else {
			y = minimum(v->right); //следующая по значению за v вершина 
			if (y->right != this->null) {
				y->right->parent = y->parent;
			}
			if (y == this->root) {
				this->root = y->right;
			}
			else
			{
				
			}
		}

	}

};

int main() {

}>)
```

[^1]: Дерево называется сбалансированным тогда и только тогда, когда для каждого его узла высоты его левого и правого поддеревьев отличаются не более чем на единицу.
[^2]: [[Метод математической индукции]] 