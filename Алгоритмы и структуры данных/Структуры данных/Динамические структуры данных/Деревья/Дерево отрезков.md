это структура данных, которая позволяет за асимптотику O(log N) реализовать любые операции, определяемые на множестве, на котором данная операция ассоциативна, и существует нейтральный элемент относительно этой операции, то есть на моноиде[^1]. Например, суммирование на множестве натуральных чисел, поиск минимума на любом числовом множестве, перемножение матриц на множестве матриц размера NxN, объединение множеств, поиск наибольшего общего делителя на множестве целых чисел и многочленов.

При этом дополнительно возможно изменение элементов массива: как изменение значения одного элемента, так и изменение элементов на целом подотрезке массива. Реализация массового обновления", например разрешается присвоить всем элементам a \[l…r\] какое-либо значение, либо прибавить ко всем элементам массива какое-либо число. Структура занимает O(N) памяти, а ее построение требует O(N) времени.


***Пример ДО для решения задачи нахождения суммы на отрезке:***

Операция сложения является ассоциативной, нейтральным элементом является 0, значит мы имеем права построить ДО. 

У нас есть массив a\[i\] из n элементов, и мы хотим уметь делать 2 операции:
- set(i, v) - присвоить i-тому элементу значение v;
- sum(l ,r) - найти сумму на отрезке от l до r - 1

Обратите внимание, что в запросе на сумму мы левую границу l берем включительно, а правая граница r исключительно. 


***Структура ДО:***

Давайте представим, что нам нужно построить дерево отрезков для следующего массива:

![[Pasted image 20230306122535.png]]

Дерево отрезков будет устроено так. Это двоичное дерево, в листьях которого находятся элементы исходного массива, а в каждом внутреннем узле записана сумма чисел в его детях.

![[Pasted image 20230306122719.png]]

Обратите внимание, что дерево получилось таким красивым, потому что длина массива была степенью двойки. Если длина массива не степень двойки, можно дополнить массив нулями до ближайшей степени двойки. При этом длина массива увеличится не больше, чем в два раза, поэтому ассимптотика работы операций не изменится. Способ хранения дерева в памяти описан в статье [[Дерево]].

Для начала проинициализируем ДО (все далее описанные методы будут содержаться в этой структуре): 

```C
struct segment_tree {
	struct node {
        int x;
    };

    vector<node> tree;
    int size;

    node combine(node a, node b) {
        return { a.x + b.x };
    }

    const node ZERO = { 0 };

    void init(int n) {
        size = 1;
        while (size < n) { //приведём размер структуры до степени двойки
            size *= 2;
        }
        tree.assign(2 * size - 1, ZERO); //заполним структуру нейтральным для операции элементом
    }

    node one_element(int x) {
        return {
            x
        };
    }
```


Теперь нужно за О(N) построить ДО на основе имеющегося массива: 

```C
void build(vector<int>& a, int x, int lx, int rx) {
        if (rx - lx == 1) { //если лист дерева (элемент исходного массива)
            if (lx < a.size()) {
                tree[x] = one_element(a[lx]);
            }
        }
        else {
            int m = (lx + rx) / 2; //делим отрезов на 2 половины 
            build(a, 2 * x + 1, lx, m); //запускаемся от левой части
            build(a, 2 * x + 2, m, rx); //запускаемся от правой части
            tree[x] = combine(tree[2 * x + 1], tree[2 * x + 2]);
        }
    }

void build(vector<int>& a) { //задаём рекурсию 
    init(a.size());
    build(a, 0, 0, size);
}
```


Теперь давайте разберем, как делать операции на таком дереве...

***Операция set***

Начнем с операции set. Когда изменяется элемент массива, нужно изменить соответствующее число в листе дерева отрезков, и далее пересчитать значения, которые от этого изменятся. Это те значения, которые находятся выше по дереву от измененного листа. Для пересчета просто заново посчитаем значение как сумму значений в детях. 

![[Pasted image 20230306122907.png]]

При совершении такой операции нам нужно пересчитать по одному узлу на каждом слое дерева отрезков. Слоев у нас всего log N, значит время работы операции будет O(log N).

```C
void set(int i, int v, int x, int lx, int rx) {
        if (rx - lx == 1) { //если лист
            tree[x] = one_element(v);
            return;
        }
        int m = (lx + rx) / 2; //делим отрезок на 2 половины 
        if (i < m) {
            set(i, v, 2 * x + 1, lx, m); //запускаемся от левого отрезка 
        }
        else {
            set(i, v, 2 * x + 2, m, rx); //запускаемся от правого отрезка 
        }
        tree[x] = combine(tree[2 * x + 1], tree[2 * x + 2]); //складываем на подъёме 
                                                             // из рекурсии 
    }

void set(int i, int v) { //задаём рекурсию
    set(i - 1, v, 0, 0, size);
}
```

***Операция sum***

Теперь давайте разберем, как вычислять сумму на отрезке. Для этого давайте сначала посмотрим, что за числа написаны в узлах дерева отрезков. Заметим, что эти числа — это суммы на каких-то отрезках исходного массива. 

![[Pasted image 20230306123051.png]]


При этом, например, число в корне — это сумма на всем массиве, а числа в листьях — это сумма на отрезке из одного элемента.

Давайте попробуем собрать сумму на отрезке \[l..r) из этих, уже посчитанных, сумм. Для этого запустим рекурсивный обход дерева отрезков. При этом будем обрывать рекурсию в двух ситуациях.

-   Отрезок, соответствующий текущему узлу, не пересекается с отрезком \[l..r). В этом случае все элементы в этом поддереве находятся вне области, в которой нам нужно посчитать сумму, поэтому глубже можно не идти.
-   Отрезок, соответствующий текущему узлу, целиком вложен в отрезок \[l..r). В этом случае все элементы в этом поддереве находятся в области, в которой нам нужно посчитать сумму, поэтому нам нужно добавить к ответу их сумму, которая записана в текущем узле.

![[Pasted image 20230306123201.png]]

Здесь крестиком обозначены вершины, в которых рекурсия оборвалась по первому отсечению, а в кружок обведены вершины, в которых число добавилось к ответу, и рекурсия оборвалась по второму отсечению. Сколько же времени работает такой обход дерева? Чтобы ответить на этот вопрос, нужно понять, в скольких вершинах не случится ни одно из отсечений, и нам надо будет идти глубже по дереву. Каждый такой случай порождает нам новую ветку рекурсии. Оказывается, что таких вершин будет довольно мало. Дело в том, что для того, чтобы не сработало ни одно из отсечений, отрезок, соответствующий вершине дерева, должен пересекать отрезок запроса, но не содержаться в нем целиком. Это возможно только, если он содержит одну из границ отрезка \[l..r). Но на каждом слое дерева отрезков может быть не более одного отрезка, содержащего каждую из границ. Таким образом, вершин, в которых не сработали отсечения, может быть не больше 2 log N, и, следовательно, общая ассимптотика работы этой процедуры будет O(log N).

```C
 int calc(int l, int r, int x, int lx, int rx) {
        if (l >= rx || lx >= r) { //если отрезки не пересекаются
            return 0;
        }
        if (lx >= l && rx <= r) { //если найденный отрезок включён в общий 
            return tree[x].x;
        }
        int m = (lx + rx) / 2; //если пересекаются, то делим отрезок на 2 половины
        long long s1 = calc(l, r, 2 * x + 1, lx, m);
        long long s2 = calc(l, r, 2 * x + 2, m, rx);
        return s1 + s2;
    }

int sum(int x) { //задаём рекурсию 
    int ans = calc(x, size, 0, 0, size);
    return ans;
}
```



***Вся структура выглядит следующим образом:***

```C
struct segment_tree {

    struct node {
        int x;
    };

    vector<node> tree;
    int size;

    node combine(node a, node b) {
        return { a.x + b.x };
    }

    const node ZERO = { 0 };

    void init(int n) {
        size = 1;
        while (size < n) { //приведём размер структуры до степени двойки
            size *= 2;
        }
        tree.assign(2 * size - 1, ZERO); //заполним структуру нейтральным для операции элементом
    }

    node one_element(int x) {
        return {
            x
        };
    }

    void build(vector<int>& a, int x, int lx, int rx) {
        if (rx - lx == 1) { //если лист дерева (элемент исходного массива)
            if (lx < a.size()) {
                tree[x] = one_element(a[lx]);
            }
        }
        else {
            int m = (lx + rx) / 2; //делим отрезов на 2 половины 
            build(a, 2 * x + 1, lx, m); //запускаемся от левой части
            build(a, 2 * x + 2, m, rx); //запускаемся от правой части
            tree[x] = combine(tree[2 * x + 1], tree[2 * x + 2]);
        }
    }

    void build(vector<int>& a) { //задаём рекурсию 
        init(a.size());
        build(a, 0, 0, size);
    }

    void set(int i, int v, int x, int lx, int rx) {
        if (rx - lx == 1) { //если лист
            tree[x] = one_element(v);
            return;
        }
        int m = (lx + rx) / 2; //делим отрезок на 2 половины 
        if (i < m) {
            set(i, v, 2 * x + 1, lx, m); //запускаемся от левого отрезка 
        }
        else {
            set(i, v, 2 * x + 2, m, rx); //запускаемся от правого отрезка 
        }
        tree[x] = combine(tree[2 * x + 1], tree[2 * x + 2]); //складываем на подъёме 
                                                             // из рекурсии 
    }

    void set(int i, int v) { //задаём рекурсию
        set(i - 1, v, 0, 0, size);
    }

    int calc(int l, int r, int x, int lx, int rx) {
        if (l >= rx || lx >= r) { //если отрезки не пересекаются
            return 0;
        }
        if (lx >= l && rx <= r) { //если найденный отрезок включён в общий 
            return tree[x].x;
        }
        int m = (lx + rx) / 2; //если пересекаются, то делим отрезок на 2 половины
        long long s1 = calc(l, r, 2 * x + 1, lx, m);
        long long s2 = calc(l, r, 2 * x + 2, m, rx);
        return s1 + s2;
    }

    int sum(int x) { //задаём рекурсию 
        int ans = calc(x, size, 0, 0, size);
        return ans;
    }
};
```

[^1]: [[Моноид]]