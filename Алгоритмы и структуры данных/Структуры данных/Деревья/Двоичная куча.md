Представляет собой полное бинарное дерево[^1], для которого выполняется основное свойство кучи: приоритет каждой вершины больше приоритетов её потомков. В простейшем случае приоритет каждой вершины можно считать равным её значению. 

Двоичную кучу удобно хранить в виде одномерного массива, причем левый потомок вершины с индексом **`i`** имеет индекс **`2*i+1`**, а правый **`2*i+2`**. Корень дерева – элемент с индексом 0. Высота двоичной кучи равна высоте дерева, то есть log2 N, где **N** – количество элементов массива. 


**Добавление элемента**

Новый элемент добавляется на последнее место в массиве, то есть позицию с индексом heap_size. 

![[Pasted image 20230228155036.png]]

Возможно, что при этом будет нарушено основное свойство кучи, так как новый элемент может быть больше родителя. В таком случае следует «поднимать» новый элемент на один уровень (менять с вершиной-родителем) до тех пор, пока не будет соблюдено основное свойство кучи:

![[Pasted image 20230228155150.png]]

Иначе говоря, новый элемент «всплывает», «проталкивается» вверх, пока не займет свое место. Сложность алгоритма не превышает высоты двоичной кучи (так как количество «подъемов» не больше высоты дерева), то есть равна O(log N). 

```Java 
public void add(vector<int>&v, int value) {
    v.push_back(value);
    int i = v.size() - 1;
    int parent = (i - 1) / 2;

    while (i > 0 && list[parent] < list[i])
    {
        int temp = v[i];
        v[i] = v[parent];
        v[parent] = temp;

        i = parent;
        parent = (i - 1) / 2;
    }
}
```


**Упорядочение двоичной кучи**

В ходе других операций с уже построенной двоичной кучей также может нарушиться основное свойство кучи: вершина может стать меньше своего потомка.

![[Pasted image 20230228155820.png]]

Метод **`heapify`** восстанавливает основное свойство кучи для дерева с корнем в i-ой вершине при условии, что оба поддерева ему удовлетворяют. Для этого необходимо «опускать» i-ую вершину (менять местами с наибольшим из потомков), пока основное свойство не будет восстановлено (процесс завершится, когда не найдется потомка, большего своего родителя). Нетрудно понять, что сложность этого алгоритма также равна O(log2 N).

![[Pasted image 20230228160141.png]]

```Java 
void heapify(vector<int>& arr, int size, int i) {
    int max = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < size && arr[left] > arr[max])
        max = left;
    if (right < size && arr[right] > arr[max])
        max = right;
        
    if (max != i) {
        int temp = arr[i];
        arr[i] = arr[max];
        arr[max] = temp;
        
        heapify(arr, size, max);
    }
}
```


**Построение двоичной кучи**

Наиболее очевидный способ построить кучу из неупорядоченного массива – это по очереди добавить все его элементы. Временная оценка такого алгоритма O(N log2 N). Однако можно построить кучу еще быстрее — за О(N). Сначала следует построить дерево из всех элементов массива, не заботясь о соблюдении основного свойства кучи, а потом вызвать метод **`heapify`** для всех вершин, у которых есть хотя бы один потомок (так как поддеревья, состоящие из одной вершины без потомков, уже упорядочены). Потомки гарантированно есть у первых heap_size вершин.

```Java
void (vector<int>& arr){
	int size = arr.size();
    for (int i = size / 2 - 1; i >= 0; i--) {
        heapify(arr, size, i);
    }
}
```


**Удаление элемента (с макс. приоритетом)**

В упорядоченном **`max-heap`** максимальный элемент всегда хранится в корне. Восстановить упорядоченность двоичной кучи после удаления максимального элемента можно, поставив на его место последний элемент и вызвав **`heapify`** для корня, то есть упорядочив все дерево.

```Java
int getMax(vector<int>& v, int& size) {
	int result = v[0];
	
	int tmp = v[0];
	v[0] = v[size - 1];
	v[size - 1] = tmp;
	
	v.pop_back();
	size--;
	heapify(v, size, 0);
	
	return result;
}
```

[^1]: [[Дерево]] является полным бинарным,  если у каждой вершины есть не более двух потомков, а заполнение уровней вершин идет сверху вниз (в пределах одного уровня – слева направо).