Структура данных[^1], хранящая набор значений, идентифицируемых по индексу или набору индексов, принимающих целые значения из некоторого заданного непрерывного диапазона. 

Размерность массива — это количество индексов, необходимое для однозначной адресации элемента в рамках массива. По количеству используемых индексов массивы делятся на одномерные, двумерные, трёхмерные и т. д.

Форма или структура массива — сведения о количестве размерностей и размере (протяжённости) массива по каждой из размерностей; может быть представлена одномерным массивом.

Особенностью массива как структуры данных (в отличие, например, от связного списка[^2]является константная вычислительная сложность[^3] доступа к элементу массива по индексу. Массив относится к структурам данных с произвольным доступом.

В простейшем случае массив имеет константную длину по всем размерностям и может хранить данные только одного, заданного при описании, типа. Ряд языков поддерживает также динамические массивы, длина которых может изменяться во время выполнения программы, и гетерогенные массивы, которые могут в разных элементах хранить данные различных типов. 

Основные достоинства использования массивов — лёгкость вычисления адреса элемента по его индексу (поскольку элементы массива располагаются один за другим), одинаковое время доступа ко всем элементам, малый размер элементов (они состоят только из информационного поля). Среди недостатков — невозможность удаления или добавления элемента без сдвига других при использовании статических массивов, а при использовании динамических и гетерогенных массивов — более низкое быстродействие из-за накладных расходов на поддержку динамики и разнородности. При работе с массивами с реализацией по типу языка Си (с указателями[^4]) и отсутствии дополнительных средств контроля типичной ошибкой времени выполнения является угроза выхода за границы массива и повреждения данных. Кроме того, данные могут храниться длинными последовательными блоками, что с определённого момента может приводить к утечками памяти[^5]. 


**Операции на С++**


Операция индексации:

```Java
	int arr[5] = { 1, 2, 3, 4, 5 };    //создаём массив на 5 элементов
    cout << arr << endl;    //выведет какой-то адрес x
    cout << &arr[0] << endl; //выведет такой же адрес х
    int* ptr = &arr[1];                //указатель на элемент "2" с индексом 1
    ptr++;                             //смещаем указатель на 1 вправо 
    cout << *ptr << endl;    //разыменовываем указатель (выводится "3")
``` 
Работает за О(1). Адрес i-го элемента B + S*i, где B - база (адрес начала блока памяти), S - размер одного элемента.


Операция поиска: 

```Java
	int arr[10] = { 10, 4, 7, 1, 2, 3, 6, 8, 9, 6 };
    int element = 6;
    int index = -1;
    for (int i = 0; i < 10; i++) {
        if (arr[i] == element && index == -1) {
            index = i;
        }
    }
    cout << index << endl;
```
Работает за О(n). Реализован алгоритм[^6] линейного поиска. 


Операция вставки:

```Java
void pasteInArray(int &length, int *&arr, int index, int elementToPaste) {
    int *new_arr = new int[length + 1];
    for (int i = 0; i < index; i++)
        new_arr[i] = arr[i];
    new_arr[index] = elementToPaste;
    for (int i = index + 1; i < length + 1; i++)
        new_arr[i] = arr[i - 1];
    length++;
    delete[] arr;
    arr = new_arr;
}
```
Работает за О(n).


Операция удаления: 

```Java
void deleteFromArray (int &length, int *&arr, int index) {
	for (int i = index; i < length; i++){
		arr[i] = arr[i + 1];
	}
	length--;
}
```
Работает за О(n). 

[^1]: [[Структура данных]]
[^2]: [[Связный список]]
[^3]: Про вычислительную сложность см. в статье [[Алгоритм]]
[^4]: [[Указатель]]
[^5]: [[Утечка памяти]]
[^6]: [[Алгоритм]]