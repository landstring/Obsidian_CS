[[Сортировка]]

Рассмотрим теперь идею модификации, которая была предложена Хоаром в 1960 году. Алгоритм, предложенный им, превратил одну из самых медленных сортировок в одну из самых быстрых. Единственное, что она стала неустойчивой, так как происходит обмен не между соседними элементами, а это приводит к неустойчивости.

Общая идея алгоритма такова: 
1. Выбираем опорный элемент. 
2. Меняем местами элементы так, чтобы слева были меньшие опорного, справа — большие.
3. Рекурсивно вызываем функцию для подмассивов.

```C
void quickSort(vector<int>& arr, int left, int right) {
    int i = left, j = right;
    int tmp;
    int pivot = arr[(left + right) / 2]; //выбрали опорный элемент 
    
    while (i <= j) { 
        while (arr[i] < pivot)
            i++;
        while (arr[j] > pivot)
            j--;
        if (i <= j) {
            tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
            i++;
            j--;
        }
    };

    if (left < j)
        quickSort(arr, left, j);
    if (i < right)
        quickSort(arr, i, right);
}
```


В худшем случае сортировка работает за O($N^2$). Однако в среднем работает за O(N logN). 

Можно выбрать различные варианты выбора опорного элемента: 
1. Выбрать первый, последний или средний элементы массива. В таком случае возможно подобрать массив таким образом, чтобы сложность была O(N2 ). 
2. Выбрать медиану — среднее арифметическое из первого, последнего и среднего элементов массива, причем полученный опорный элемент не обязательно должен находиться в массиве. 
3. Выбрать на каждом шаге в качестве опорного случайный элемент массива. В таком случае вероятность худшего случая очень мала. 


Быстрая сортировка легко применяется к двусвязным спискам и другим структурам, допускающим проход как в прямом, так и в обратном порядке. Также быстрая сортировка удобна для параллельных алгоритмов.