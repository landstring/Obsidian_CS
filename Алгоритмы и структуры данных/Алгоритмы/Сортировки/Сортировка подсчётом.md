[[Сортировка]]

Если известно, что элементы массива находятся в диапазоне \[0, k\]. Всего элементов N и k < N, то можно воспользоваться сортировкой подсчетом. Идея алгоритма состоит в следующем: так как 
k < N, то в массиве обязательно будут повторяющиеся элементы. Надо подсчитать количество повторяющихся элементов. 

Я приведу более продвинутую реализацию. Алгоритм сортирует элементы любого диапазона, состоящего из целых чисел. 

```C
void counting_sort(vector<int> &v) {
    int min = *min_element(v.begin(), v.end());
    int delta = 0 - min;                              //усовершенствование алгоритма. Определяем смещение отрезка  [0, k], как delta
    int max = *max_element(v.begin(), v.end());      //и производим такую же сортировку за О(3N + k), что примерно равно O(n).  
    vector<int> B(max + delta + 1, 0);              //Работает для небольших значений (проблемы с памятью здесь будут ощущаться ещё острее)
    for (int i = 0; i < v.size(); i++) {
        B[v[i] + delta]++;
    }
    int p = 0;
    for (int i = 0; i < max + delta + 1; i++) {
        for (int j = 0; j < B[i]; j++) {
            v[p] = i - delta;
            p++;
        }
    }
}
```

Оценим сложность. Сначала делаем N шагов для того, чтобы подсчитать количество одинаковых элементов. Потом делаем k + N шагов для того, чтобы записать новые элементы в массив. Следовательно, асимптотика O(N + k). Требуется дополнительная память O(k). 