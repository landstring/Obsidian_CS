**Префикс-функция** от строки — массив длин наибольших бордеров[^1] для каждой позиции этой строки.

Здесь и далее считаем, что символы в строках нумеруются с 0.

Определим префикс-функцию от строки s в позиции i следующим образом: $$\pi(s, i) = \max\limits_{k = 1 ... i}\{k:s[0 ... k - 1] = s[i - k + 1 ... i]\}$$Если мы не нашли такого k, то $\pi(s, i) = 0$. 


***Эффективный алгоритм***

- Заметим, что $p[i + 1] \le p[i] + 1$. Чтобы показать это, рассмотрим суффикс,оканчивающийся на позиции $i + 1$ и имеющий длину $p[i + 1]$, удалив из него последний символ, мы получим суффикс, оканчивающийся на позиции i и имеющий длину $p[i + 1] - 1$, следовательно неравенство $p[i + 1] > p[i] + 1$ неверно. 
- Избавимся от явных сравнений строк. Пусть мы вычислили $p[i]$, тогда если $s[i + 1] = s[p[i]]$, то $p[i + 1] = p[i] + 1$. Если окажется, что $s[i + 1] \ne s[p[i]]$, то нужно попытаться попробовать подстроку меньшей длины. Хотелось бы сразу перейти к такому бордеру наибольшей длины, для этого подберем такое k, что $k = p[i] - 1$. Делаем это следующим образом. За исходное k необходимо взять $p[i - 1]$, что следует из первого пункта. В случае, когда символы $s[k]$ и $s[i]$
не совпадают, $p[k - 1]$ следующее потенциальное наибольшее значение k, что видно из рисунка. Последнее утверждение верно, пока $k > 0$, что позволит всегда найти его следующее значение. Если k = 0, то $p[i] = 1$ при $s[i] = s[1]$, иначе $p[i] = 0$. 

![[Pasted image 20230403105233.png]]

***Реализация***

```C
vector<int> prefix(string& s) {
	int n = (int) s.size();
	vector<int> p(n, 0);
	for (int i = 1; i < n; i++) {
		int k = p[i - 1];
		while (k > 0 && s[i] != s[k]) {
			k = p[k - 1];
		}
		if (s[i] == s[k]) {
			++k;
		}
		p[i] = k;
	}
	return p;
}
```

[^1]: Бордер строки (см. определение в статье [[Строки]])
