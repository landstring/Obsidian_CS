Алгоритм поиска подстроки в строке. 

***Описание работы алгоритма***

Дана цепочка T и образец P. Требуется найти все позиции, начиная с которых P входит в T.
Построим строку S = P#T, где # - любой символ, не входящий в алфавит P и T. Посчитаем на ней значение префикс-функции[^1] p. Благодаря разделительному символу #, выполняется $\forall i:p[i] \le |P|$. Заметим, что по определению префикс при $i > |P|$ и $p[i] = |P|$ подстроки длины P, начинающиеся с позиций 0 и $i - |P| + 1$, совпадают. Соберём все такие позиции $i - |P| + 1$ строки S, вычтем из каждой позиции $|P| + 1$, это и будет ответ. Другими словами, если в какой-то позиции $i$ выполняется условие $p[i] = |P|$, то в этой позиции начинается очередное вхождение образца в цепочку. 

![[Pasted image 20230403140642.png]]

***Реализация***

```C
vector<int> prefix(string& s) {
	int n = s.size();
	vector<int> p(n, 0);
	for (int i = 1; i < n; i++) {
		int k = p[i - 1];
		while (k > 0 && s[i] != s[k]) {
			k = p[k - 1];
		}
		if (s[i] == s[k]) {
			++k;
		}
		p[i] = k;
	}
	return p;
}

vector<int> kmp(string p, string t) {
	string s = p + "#" + t;
	vector<int> pref = prefix(s);
	vector<int> ans;
	for (int i = 0; i < t.size(); i++) {
		if (pref[p.size() + i + 1] == p.size()) {
			ans.push_back(i - p.size() + 1);
		}
	}
	return ans;
}
```

[^1]: См. статью [[Префикс-функция]]