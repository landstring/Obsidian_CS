**Z-функция** от строки S в позиции x - это длина максимального префикса подстроки, начинающейся с позиции x в строке S, который одновременно является и префиксом всей строки S.[^1] $$Z[i](s) = \max k | s[i ... i + k] = s [0 ... k] $$ Значение Z-функции от первой позиции не определено, поэтому его обычно приравнивают к нулю или к длине строки.

![[Pasted image 20230403111640.png]]

***Эффективный алгоритм***

Z-блоком назовем подстроку с началом в позиции i и длиной $Z[i]$.
Для работы алгоритма заведём две переменные: left и right - начало и конец Z-блока от 0 до i - 1. Найдём $Z[i]$. Рассмотрим 2 случая: 
1. $i > right$:
	Просто пробегаемся по строке S и сравним символы на позициях $S[i + j]$ и $S[j]$. Пусть j - первая позиция в строке S для которой не выполняется равенство $S[i + j] = S[j]$, тогда j - это и Z-функция для позиции i. Тогда $left = i$, $right  = i + j - 1$. В данном случае будет определено корректное значение $Z[i]$ в силу того, что оно определяется наивно, путем сравнения с начальными символами строки.
2. $i \le right$:
	Сравним $Z[i - left] + i$ и $right$. Если $right$ меньше, то надо просто наивно пробежаться по строке начиная с позиции $right$ и вычислить значение $Z[i]$. Корректность в таком случае также гарантирована.Иначе мы уже знаем верное значение $Z[i]$, так как оно равно значению $Z[i - left]$. 

![[Pasted image 20230403112907.png]]
![[Pasted image 20230403135652.png]]

***Реализация***

```C
vector<int> Z_function(string& s) {
	int n = s.size();
	vector<int> z(n);
	int l = 0, r = 0;
	for (int i = 0; i < n; i++) {
		if (i <= r) {
			z[i] = min(r - i + 1, z[i - l]);
		}
		while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
			z[i]++;
		}
		if (i + z[i] - 1 > r) {
			l = i, r = i + z[i] - 1;
		}
	}
	return z;
}
```
[^1]: См. статью [[Строки]]
