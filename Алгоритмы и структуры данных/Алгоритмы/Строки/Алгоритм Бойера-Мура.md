**Алгоритм Бойера-Мура**, разработанный двумя учеными — Бойером (Robert S. Boyer) и Муром (J. Strother Moore), считается наиболее быстрым среди алгоритмов общего назначения, предназначенных для поиска подстроки в строке. Важной особенностью алгоритма является то, что он выполняет сравнения в шаблоне справа налево в отличие от многих других алгоритмов.[^1] 

Алгоритм Бойера-Мура считается наиболее эффективным алгоритмом поиска шаблонов в стандартных приложениях и командах, таких как Ctrl+F в браузерах и текстовых редакторах. 


***Алгоритм***

Алгоритм сравнивает символы шаблона x справа налево, начиная с самого правого, один за другим с символами исходной строки y. Если символы совпадают, производится сравнение предпоследнего символа шаблона и так до конца. Если все символы шаблона совпали с наложенными символами строки, значит, подстрока найдена, и поиск окончен. В случае несовпадения какого-либо символа (или полного совпадения всего шаблона) он использует две предварительно вычисляемых эвристических функций, чтобы сдвинуть позицию для начала сравнения вправо. 

Таким образом для сдвига позиции начала сравнения алгоритм Бойера-Мура выбирает между двумя функциями, называемыми эвристиками хорошего суффикса и плохого символа (иногда они называются эвристиками совпавшего суффикса и стоп-символа). Так как функции эвристические, то выбор между ними простой — ищется такое итоговое значение, чтобы мы не проверяли максимальное число позиций и при этом нашли все подстроки равные шаблону.

Алфавит обозначим буквой $\Sigma$.

Пусть $|y| = n, |x| = m, |\Sigma| = \sigma$ 

Предположим, что в процессе сравнения возникает несовпадение между символом $x[i] = a$ шаблона и символом $y[i + j] = b$ исходного текста при проверке в позиции j. Тогда $x[i + 1 ... m - 1] = y[i + j + 1 ... j + m - 1] = u$, и $x[i] \ne y[i + j]$, и $m - i - 1$ символов шаблона уже совпало. 


**Правило сдвига хорошего суффикса**

Если при сравнении текста и шаблона совпало один или больше символов, шаблон сдвигается в зависимости от того, какой суффикс совпал.

Если существуют такие подстроки равные $u$, что они полностью входят в $x$ и идут справа от символов, отличных от $x[i]$, то сдвиг происходит к самой правой из них, отличной от $u$. Понятно, что таким образом мы не пропустим никакую строку, так как сдвиг просходит на следующую слева подстроку $u$ от суффикса. После выравнивания шаблона по этой подстроке сравнение шаблона опять начнется с его последнего символа. На новом шаге алгоритма можно строку $u$, по которой был произведён cдвиг, не сравнивать с текстом — возможность для модификации и дальнейшего ускорения алгоритма. 

![[Pasted image 20230403200100.png]]

Если не существует таких подстрок, то смещение состоит в выравнивании самого длинного суффикса $v$ подстроки $y[i + j + 1 ... j + m - 1]$ с соответствующим префиксом $x$. Из-за того, что мы не смогли найти такую подстроку, то, очевидно, что ни один суффикс шаблона $x$ уже не будет лежать в подстроке $y[i + j + 1 ... j + m - 1]$, поэтому единственный вариант, что в эту подстроку попадет префикс. 

![[Pasted image 20230403200231.png]]


***Правило сдвига плохого символа***

В таблице плохих символов указывается последняя позиция в шаблоне (исключая последнюю букву) каждого из символов алфавита. Для всех символов, не вошедших в шаблон, пишем $m$. Предположим, что у нас не совпал символ $c$ из текста на очередном шаге с символом из шаблона. Очевидно, что в таком случае мы можем сдвинуть шаблон до первого вхождения этого символа $c$ в шаблоне, потому что совпадений других символов точно не может быть. Если в шаблоне такого символа нет, то можно сдвинуть весь шаблон полностью.

Если символ исходного текста $y[i + j]$ встречается в шаблоне $x$, то происходит его выравнивание с его самым правым появлением в подстроке $x[0 ... m - 2]$.

![[Pasted image 20230403200608.png]]

Если $y[i + j]$ не встречается в шаблоне $x$, то ни одно вхождение $x$ в $y$ не может включать в себя $y[i + j]$, и левый конец окна сравнения совмещен с символом непосредственно идущим после $y[i + j]$, то есть символ $y[i + j + 1]$.

![[Pasted image 20230403200747.png]]

Обратите внимание, что сдвиг плохого символа может быть отрицательным, поэтому исходя из ранее приведенных свойств этих функций берется значение равное максимуму между сдвигом хорошего суффикса и сдвигом плохого символа.


***Формальное определение***

Теперь определим две функции сдвигов более формально следующим образом:

Пусть значения функции сдвига хорошего суффикса хранятся в массиве $bmGs$ размером $m + 1$.

Определим два условия:
- $Cs(i, s)$: для каждого k такого, что $i < k < m$ выполняется $s \ge k$ или $x[k - s] = x[k]$ 
- $Co(i, s)$: если $s < i$, то выполняется $x[i - s] \ne x[i]$ 

Тогда для всех $i$ таких, что $0 \le i < m$ выполняется $bmGs[i + 1] = \min\{s > 0: Cs(i, s) \land Co(i, s)\}$. 

А значение $bmGs[0]$ определим, как длину периода шаблона $x$. 

Для вычисления $bmGs$ будем использовать функцию $suffixLength$, определенную так: для всех $i$ таких, что $1 \le i < m$ $suffixLength(i) = \max\{k: x[i - k + 1 ... i] = x[m - k ... m - 1]\}$ 

Сдвиги плохих символов будем хранить в массиве $bmBc$ размером $\sigma$. Для каждого символа $c$ из $\Sigma$: $$ bmBc[c] =
  \begin{cases}
\min\{i : 1 \le i < m - 1 \land x[m - 1 - i] = c\}, \text{if } c \in x \\
m, \text{otherwise}
  \end{cases}
$$

***Асимптотики***

- Фаза предварительных вычислений требует $(m^{2} + \sigma)$ времени и памяти.
- В худшем случае поиск требует $O(m * n)$ сравнений.
- В лучшем случае требует $\Omega(\frac{n}{m})$ сравнений. 

```C

```